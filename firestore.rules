/**
 * This Firestore Security Ruleset is designed for the GeoShield application, a
 * real-time military unit tracking and operations management system.
 *
 * Core Philosophy:
 * The security model implements a Role-Based Access Control (RBAC) system
 * without relying on custom claims. A user's permissions are derived directly
 * from their user document stored in the `/users/{userId}` collection. This
 * document contains their role ('commander' or 'sub-commander') and unit
 * assignments, which dictates their access to sensitive military data. Publicly
 * accessible data is explicitly segregated into its own collection.
 *
 * Data Structure:
 * The data is organized into four distinct, top-level collections:
 * - `/users/{userId}`: Stores user profile information, including authorization roles.
 * - `/military_units/{militaryUnitId}`: Contains sensitive data about military units.
 * - `/operation_targets/{operationTargetId}`: Holds details about operational targets.
 * - `/decoys/{decoyId}`: A public collection of decoy coordinates.
 *
 * Key Security Decisions:
 * - Commander Privilege: Users with the 'commander' role have broad read and write
 *   access across `military_units` and `operation_targets`.
 * - Sub-Commander Access: Sub-commanders have restricted access. Their ability to
 *   view data is determined by the `canSeeAllUnits` flag or their specific
 *   `assignedUnitId` in their user profile.
 * - Default Deny: All operations are denied by default. Access must be
 *   explicitly granted.
 * - No User Enumeration: Listing users is explicitly disallowed to protect user privacy.
 * - Public Data Segregation: Decoy data, which is meant to be public, is stored in a
 *   separate `/decoys` collection with open read access, while all writes are
 *   denied from the client. This is more secure and performant than mixing public
 *   and private data.
 *
 * Denormalization for Authorization:
 * To enable fast and secure authorization checks, key data is denormalized:
 * - User permissions (role, canSeeAllUnits, assignedUnitId) are stored directly on the
 *   `/users/{userId}` document. Rules use `get()` to fetch the requesting user's
 *   profile to make authorization decisions, avoiding complex queries or joins.
 * - The `assignedUnitId` is denormalized onto `/operation_targets` documents, allowing
 *   rules to authorize sub-commander access without needing to reference the parent
 *   `military_unit` document.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ------------------------------------------------------------------------
    // Helper Functions
    // ------------------------------------------------------------------------

    /**
     * Returns true if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Returns true if the authenticated user's UID matches the provided userId.
     * This is the foundation of the ownership-based security model.
     * @param userId The user ID to check against the authenticated user.
     */
    function isOwner(userId) {
      // In this app, auth is based on a custom system, not Firebase Auth UID.
      // We will rely on document data for ownership-like checks.
      // For user documents, we can check the incoming write against the userId in path.
      return true; // Placeholder, real checks are in the rules.
    }

    /**
     * Retrieves the user data document from the /users collection based on the
     * custom login system's username. This is a conceptual function.
     * In practice, we can't query by username in rules. We get the user doc by ID.
     * The `request.auth.uid` would be the document ID of the logged-in user.
     * For this custom auth, we will assume client provides the user ID for lookups,
     * and we must validate it's their own document.
     */
    function getUserData(userId) {
      return get(/databases/$(database)/documents/users/$(userId)).data;
    }

    /**
     * Checks if the user associated with `userId` has the 'commander' role.
     */
    function isCommander(userId) {
      // For our custom auth, we can't reliably get the current user's role
      // without their ID. We'll pass the ID from the client.
      // This is less secure but required by the custom auth design.
      // A more secure way is to use custom tokens.
      // Let's assume there is a global admin with a known ID 'admin_nicat'
      return userId == 'admin_nicat';
    }
    
    // The functions below are designed for a standard Firebase Auth setup.
    // Given the custom auth, we will adapt the logic inside the match blocks.
    // The principle remains: check roles and assignments from the /users/{userId} document.

    // ------------------------------------------------------------------------
    // Collection Rules
    // ------------------------------------------------------------------------

    /**
     * @description Controls access to military unit documents. Commanders can manage
     *              and see all units. Sub-commanders can see all units if granted
     *              the `canSeeAllUnits` permission, or otherwise can only see the
     *              specific unit they are assigned to.
     */
    match /military_units/{militaryUnitId} {
      // Allow read if user is commander, or has canSeeAllUnits flag, or is assigned to this specific unit.
      allow get: if isSignedIn() && (
                    getUserData(request.auth.uid).role == 'commander' ||
                    getUserData(request.auth.uid).canSeeAllUnits == true ||
                    getUserData(request.auth.uid).assignedUnitId == militaryUnitId
                  );
      // Allow list only if user is commander or has canSeeAllUnits flag.
      allow list: if isSignedIn() && (
                    getUserData(request.auth.uid).role == 'commander' ||
                    getUserData(request.auth.uid).canSeeAllUnits == true
                  );
      // Only commanders can create, update, or delete units.
      allow write: if isSignedIn() && getUserData(request.auth.uid).role == 'commander';
    }

    /**
     * @description Secures operation target documents. Commanders have full control.
     *              Sub-commanders can only view targets assigned to their own unit.
     */
    match /operation_targets/{operationTargetId} {
      // Allow read if user is commander, or is assigned to the unit of this target.
      allow get: if isSignedIn() && (
                    getUserData(request.auth.uid).role == 'commander' ||
                    getUserData(request.auth.uid).assignedUnitId == resource.data.assignedUnitId
                  );
      // List is restricted. Client queries must be specific. Commander can list all.
      // Sub-commanders can only query for targets matching their unitId.
      allow list: if isSignedIn() && (
                    getUserData(request.auth.uid).role == 'commander' ||
                    request.query.where[0][2] == getUserData(request.auth.uid).assignedUnitId
                  );
      // Only commanders can create, update, or delete targets.
      allow write: if isSignedIn() && getUserData(request.auth.uid).role == 'commander';
    }

    /**
     * @description Manages decoy coordinates. This data is public.
     *              All client-side write operations are forbidden.
     */
    match /decoys/{decoyId} {
      allow get, list: if true;
      allow write: if false; // Managed by a secure backend (the Genkit flow)
    }

    /**
     * @description Defines rules for user profile documents. Users can read and
     *              update their own document. Commanders can update any user doc (to change permissions).
     */
    match /users/{userId} {
      // User can get their own doc. Commander can get any.
      allow get: if isSignedIn() && (request.auth.uid == userId || getUserData(request.auth.uid).role == 'commander');
      // No one can list all users.
      allow list: if false;
      // Anyone can create a user doc (signup), but the ID must match their auth UID.
      allow create: if isSignedIn() && request.auth.uid == userId;
      // User can update their own doc. Commander can update any doc.
      allow update: if isSignedIn() && (request.auth.uid == userId || getUserData(request.auth.uid).role == 'commander');
      // User can delete their own account. Commander can delete any.
      allow delete: if isSignedIn() && (request.auth.uid == userId || getUserData(request.auth.uid).role == 'commander');
    }
  }
}
